import sys


def decode_token(key: list[str], token: str, is_upper: bool) -> str:
    """
    Decodes a token of message
    Tokens can be generated by tokenize_encoded_message
    Args:
    key (list) : Key used for decoding
    token (str): token to decode
    Returns:
    (str) Decoded token
    """
    key_index = int(token[0]) - 1
    char_index = len(token) - 1
    try:
        result = key[key_index][char_index]
    except IndexError:
        return None
    if is_upper:
        result = result.upper()
    return result


def decode_message(key: list, message: str) -> str:
    """
    Decoded a complete message
    Args:
    key (list) : Key used for decoding
    message (str): message to decode
    Returns:
    (str) Decoded Message
    """
    result = ""
    tokenized_msg, is_upper = tokenize_encoded_message(message)
    for token, upper in zip(tokenized_msg, is_upper):
        decoded_token = decode_token(key, token, upper)
        if decoded_token is None:
            return "Error"
        result += decoded_token
    return result


def encode_char(key: list[str], char: str) -> str:
    """
    Encoded one character of message
    Args:
    key (list) : Key used for encoding
    char (str): character to encode
    Returns:
    (str) Encoded word
    """
    result = ""
    if char.isupper():
        result += "0"
    char = char.lower()
    key_index = 0
    char_index = 0
    for i, word in enumerate(key):
        if char in word:
            key_index = i + 1
            char_index = word.index(char) + 1
    if key_index == 0:
        return None
    else:
        result += str(key_index) * char_index + "0"
        return result


def encode_message(key: list[str], message: str) -> str:
    """
    Encodes a complete message
    Args:
    key (list) : Key used for encoding
    message (str): Message to encode
    Returns:
    (str) Encoded string
    """
    result = ""
    for char in message:
        encoded_char = encode_char(key, char)
        if encoded_char is None:
            return "Error"
        else:
            result += encoded_char
    return result


def tokenize_encoded_message(message: str) -> (list[str], list[bool]):
    """
    Tokenizes the encoded message into parts
    Args:
    message (str) : encoded message

    Returns:
    (tuple) : tuple of tokenized words in encoded message
              and is_upper list that indicates whether word is uppercase
              or not i.e. preceded by 0 (other than the delimiter)
    """
    is_upper = []
    tokenized_message = []
    split_message = message.split("0")
    # ignore the last delim
    del split_message[-1]
    is_upper_ahead = False
    for tok in split_message:
        if tok == "":
            is_upper.append(True)
            is_upper_ahead = True
            continue
        elif not is_upper_ahead:
            is_upper.append(False)
        tokenized_message.append(tok)
        is_upper_ahead = False
    return tokenized_message, is_upper


if __name__ == "__main__":
    with open(sys.argv[1], "r") as file:
        key = file.readline().strip().split(",")
        # sanitize the read key
        # Input containes double quotes (")
        # Need to remove it to make a list of strings
        for i in range(0, len(key)):
            key[i] = key[i].strip().replace('"', "").lower()
        operation = int(file.readline().strip())
        message = file.readline().strip()
    if operation == 2:
        print(decode_message(key, message))
    elif operation == 1:
        print(encode_message(key, message))
